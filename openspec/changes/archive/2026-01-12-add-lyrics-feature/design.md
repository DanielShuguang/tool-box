# 设计文档：歌词功能

## 上下文

当前音乐播放器已具备完整的播放、列表管理等功能，但缺少歌词显示功能。用户希望在播放音乐时能够查看同步歌词，以获得更好的音乐体验。

本设计文档描述歌词功能的技术实现方案，包括歌词获取、缓存、显示和用户交互等各个方面。

## 目标 / 非目标

### 目标

- 集成QQ音乐歌词API，支持歌词搜索和获取
- 实现歌词本地缓存机制，支持LRU淘汰策略
- 在播放器页面显示歌词，支持100ms精度的同步高亮
- 支持用户手动编辑歌词和上传本地歌词文件
- 在应用设置中提供缓存路径和容量配置
- 提供缓存手动清理功能
- 预留桌面歌词显示接口，便于后续功能扩展

### 非目标

- 桌面歌词悬浮窗口显示（当前版本仅在播放器页面显示，预留扩展接口）
- 歌词翻译功能
- 歌词分享功能
- 卡拉OK特效
- 歌词社区功能（评论、点赞等）

## 决策

### 决策 1：歌词缓存文件格式

**选择**：JSON文件格式，按歌曲ID命名

**理由**：

- JSON格式易于读写和调试
- 便于后续扩展元数据（歌手、专辑等）
- 按歌曲ID命名可直接映射，避免名称冲突
- 与项目现有的配置存储风格一致

**格式示例**：

```json
{
  "trackId": "song-123",
  "songName": "晴天",
  "artist": "周杰伦",
  "source": "QQMusic",
  "format": "lrc",
  "cachedAt": "2026-01-11T10:00:00Z",
  "lyrics": [
    {
      "time": 0.0,
      "text": "故事的小黄花"
    },
    {
      "time": 5.32,
      "text": "从出生那年就飘着"
    }
  ]
}
```

**考虑的替代方案**：

- 直接存储LRC原文（无需解析）
  - 优点：简单、存储空间小
  - 缺点：无法进行二次解析，灵活性差
- 使用SQLite数据库存储
  - 优点：查询效率高、关系型数据管理
  - 缺点：增加项目依赖、维护复杂
- 决策：JSON文件格式，平衡了可维护性和性能

### 决策 2：缓存淘汰策略

**选择**：LRU（最近最少使用）算法

**理由**：

- 歌词数据具有时效性，用户最近播放的歌曲更可能再次播放
- 实现简单，无需复杂的缓存键管理
- 与常见的缓存淘汰策略一致，用户体验可预期
- 可以基于访问时间进行淘汰，不需要额外的访问计数

**考虑的替代方案**：

- LFU（最不经常使用）
  - 优点：考虑历史访问频率
  - 缺点：需要维护计数器，可能被老歌长期占用
- FIFO（先进先出）
  - 优点：实现极其简单
  - 缺点：不符合用户行为模式（最近播放的更可能需要）
- 决策：LRU算法，平衡实现复杂度和用户体验

### 决策 3：歌词显示位置

**选择**：在 `PlayerPanel.vue` 中添加歌词区域，支持全屏展开

**理由**：

- 与播放控制紧密关联，符合用户直觉
- 不影响现有播放列表的展示空间
- 支持在全屏模式下展示更大区域的歌词
- 便于与播放进度同步显示

**布局方案**：

- 普通模式：歌词区域显示在封面图下方，高度固定为200px
- 全屏模式：歌词区域扩展为全屏，支持滚动浏览

**考虑的替代方案**：

- 独立歌词面板（右侧）
  - 优点：歌词区域更大
  - 缺点：影响播放列表展示，需要调整整体布局
- 弹出窗口
  - 优点：歌词显示不占用主界面
  - 缺点：增加窗口管理复杂度
- 决策：在PlayerPanel中添加歌词区域，保持布局简洁

### 决策 4：网络请求封装

**选择**：使用现有的 `@/utils/request.ts` 封装

**理由**：

- 统一网络请求风格，保持代码一致性
- 支持重试机制，提高API调用可靠性
- 支持超时控制，避免长时间阻塞
- 项目已有现成的实现，无需引入额外依赖

**考虑的替代方案**：

- 使用axios
  - 优点：功能更丰富、生态更好
  - 缺点：增加项目依赖
- 使用Tauri HTTP插件直接调用
  - 优点：减少封装层
  - 缺点：缺少重试和错误处理
- 决策：复用现有request封装，降低复杂度

### 决策 5：歌词解析架构

**选择**：工厂模式 + 策略模式

**理由**：

- 清晰分离不同格式的解析逻辑
- 便于后续添加新格式支持
- 符合开闭原则，扩展新格式无需修改现有代码

**解析器接口**：

```typescript
interface LyricsParser {
  format: string
  parse(content: string): LyricsLine[]
}
```

**考虑的替代方案**：

- 单一解析函数 + switch分支
  - 优点：代码集中
  - 缺点：违反单一职责原则
- 决策：工厂模式，代码结构清晰，便于维护

## 风险 / 权衡

### 风险 1：QQ音乐API不稳定

**风险**：外部API可能出现请求失败、超时或返回空数据

**缓解措施**：

- 实现重试机制（默认重试2次）
- 设置合理的超时时间（5000ms）
- 缓存优先策略：优先使用本地缓存
- API失败时降级处理，显示"暂无歌词"
- 在UI上提供友好的错误提示

### 风险 2：缓存占用磁盘空间过大

**风险**：歌词缓存持续增长，可能占用大量磁盘空间

**缓解措施**：

- 设置缓存容量上限（默认100MB）
- 实现LRU自动淘汰机制
- 提供手动清理功能
- 显示当前缓存大小信息

### 风险 3：歌词同步精度不足

**风险**：播放进度更新不及时，导致歌词高亮延迟

**缓解措施**：

- 使用 `requestAnimationFrame` 进行同步更新
- 目标精度100ms，满足用户体验
- 实现预加载机制，提前计算下一行歌词

### 风险 4：歌词与音频不匹配

**风险**：搜索返回的歌词可能与实际播放的歌曲不匹配

**缓解措施**：

- 优先使用歌曲ID搜索（精确匹配）
- 关键词搜索时，提供多结果选择
- 允许用户手动编辑或替换歌词

## 迁移计划

### 阶段 1：后端实现（步骤 1.3）

1. 创建 `src-tauri/src/lyrics.rs` 文件
2. 实现 `write_lyrics_cache` 命令：保存歌词到JSON文件
3. 实现 `read_lyrics_cache` 命令：读取歌词JSON文件
4. 实现 `delete_lyrics_cache` 命令：删除单个歌词缓存
5. 实现 `clear_all_lyrics_cache` 命令：清理所有歌词缓存
6. 实现 `get_lyrics_cache_info` 命令：获取缓存统计信息

### 阶段 2：服务层实现（步骤 2.1-2.4）

1. 创建 `src/services/lyricsService.ts` 服务类
2. 封装QQ音乐歌词API调用
3. 实现错误处理和重试逻辑
4. 创建 `src/utils/lyricsParser.ts` 解析器

### 阶段 3：缓存管理（步骤 4.1-4.7）

1. 实现前后端通信封装
2. 实现本地文件缓存操作
3. 实现LRU淘汰算法
4. 实现缓存信息统计

### 阶段 4：前端逻辑（步骤 5.1-5.4）

1. 创建 `useLyrics` 核心Hook
2. 实现歌词加载逻辑（缓存优先）
3. 实现歌词同步机制
4. 管理歌词状态

### 阶段 5：UI开发（步骤 6.1-6.6）

1. 开发 `LyricsPanel` 组件
2. 实现歌词显示和滚动
3. 实现编辑和上传功能
4. 集成到播放器界面

### 阶段 6：设置集成（步骤 7.1-7.7）

1. 更新应用设置Store
2. 添加缓存路径和容量配置
3. 开发设置UI组件
4. 实现缓存清理功能

### 阶段 7：测试和优化（步骤 9.1-9.11）

1. 单元测试（歌词解析器、LRU算法）
2. 集成测试（API调用、缓存操作）
3. UI测试（组件渲染、交互）
4. 性能测试（大量歌词场景）

## 回滚计划

如果在实施过程中发现问题，可以按以下步骤回滚：

1. **移除歌词相关功能**：
   - 删除新增的前端组件和Hook
   - 删除后端歌词模块
   - 恢复appSettings的原有配置
   - 移除设置中的歌词选项

2. **数据清理**：
   - 歌词缓存文件可安全删除（不影响音乐播放）
   - 应用设置中的歌词配置会自动忽略

3. **代码回退**：
   - Git回退到上一提交
   - 所有歌词功能代码将被移除

## 待决问题

- [x] 缓存容量的默认值？（100MB，已确定）
- [x] API超时时间？（5000ms，已确定）
- [x] 歌词文件命名规则？（{trackId}.json，已确定）
- [x] 是否支持桌面歌词？（预留接口，当前版本不实现）
- [x] LRU清理触发时机？（设置容量变更时 + 保存新缓存前检查）
