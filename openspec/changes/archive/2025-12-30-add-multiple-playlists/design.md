# 设计文档：多播放列表功能

## 上下文

当前音乐播放器使用单一播放列表结构，所有音频文件存储在 `playlist: AudioFile[]` 中。用户需要能够创建和管理多个播放列表来组织不同类型的音乐。

## 目标 / 非目标

### 目标

- 支持创建、删除、重命名多个播放列表
- 提供默认播放列表，且不可修改
- 播放列表列表显示在播放列表面板左侧
- 每个播放列表独立维护排序和搜索状态
- 数据持久化，支持应用重启后恢复

### 非目标

- 播放列表的导入/导出功能
- 播放列表的拖拽排序
- 播放列表的共享功能
- 播放列表的标签或分类功能

## 决策

### 决策 1：数据结构设计

**选择**: 使用 `Playlist[]` 数组存储所有播放列表，每个播放列表包含完整的元数据和音频文件列表。

**理由**:

- 简单直接，易于理解和维护
- 每个播放列表独立，互不干扰
- 便于持久化存储和恢复

**考虑的替代方案**:

- 使用 Map 结构存储播放列表（key 为播放列表 ID）
  - 优点：查找效率更高
  - 缺点：需要额外的序列化逻辑，复杂度增加
  - 决策：当前播放列表数量不会很大，数组结构足够高效

### 决策 2：默认播放列表处理

**选择**: 默认播放列表在初始化时自动创建，通过 `isDefault: boolean` 标志标识，禁止删除和重命名。

**理由**:

- 确保用户始终有一个可用的播放列表
- 通过标志位简单实现保护逻辑
- 符合用户预期（类似系统默认文件夹）

**考虑的替代方案**:

- 使用特殊 ID（如 `'default'`）标识默认播放列表
  - 优点：不需要额外字段
  - 缺点：需要字符串比较，不够类型安全
  - 决策：使用布尔标志更清晰明确

### 决策 3：UI 布局

**选择**: 播放列表列表位于播放列表面板左侧，垂直排列，当前播放列表高亮显示。

**理由**:

- 符合用户需求（列表名排列在当前播放列表的左侧）
- 布局清晰，易于理解
- 不占用过多屏幕空间

**考虑的替代方案**:

- 使用标签页（Tabs）切换播放列表
  - 优点：切换更直观
  - 缺点：占用更多垂直空间，不符合需求
  - 决策：侧边列表更符合需求描述

### 决策 4：数据迁移策略

**选择**: 在初始化时检测旧版本数据，自动迁移到新结构。

**理由**:

- 确保向后兼容
- 用户无需手动操作即可升级
- 平滑过渡，不影响现有数据

**迁移逻辑**:

1. 检查是否存在旧的 `playlist` 字段
2. 如果存在，创建默认播放列表，将旧数据迁移到默认播放列表
3. 删除旧的 `playlist` 字段

## 风险 / 权衡

### 风险 1：数据迁移失败

- **风险**: 旧版本数据迁移时可能出现错误，导致数据丢失
- **缓解措施**:
  - 实现完善的错误处理
  - 在迁移前备份原始数据
  - 提供回滚机制

### 风险 2：性能问题

- **风险**: 播放列表数量增多时，查找和切换可能变慢
- **缓解措施**:
  - 使用计算属性缓存当前播放列表
  - 如果性能成为问题，考虑使用 Map 结构优化

### 风险 3：UI 复杂度增加

- **风险**: 添加播放列表列表后，UI 可能变得复杂
- **缓解措施**:
  - 保持 UI 简洁，只显示必要的操作
  - 使用右键菜单隐藏次要操作
  - 提供清晰的视觉反馈

## 迁移计划

### 步骤 1：数据结构准备

1. 定义新的 `Playlist` 接口
2. 更新 `MusicPlayerState` 接口
3. 实现数据迁移逻辑

### 步骤 2：功能实现

1. 实现播放列表管理功能（创建、删除、重命名）
2. 实现播放列表切换功能
3. 更新所有相关 Hook 和组件

### 步骤 3：UI 开发

1. 开发播放列表列表组件
2. 集成到播放列表面板
3. 实现交互和视觉反馈

### 步骤 4：测试和验证

1. 单元测试
2. 集成测试
3. 数据迁移测试
4. UI 测试

### 回滚计划

如果出现问题，可以：

1. 恢复旧版本代码
2. 数据会自动回退到旧格式（如果迁移逻辑有保护）
3. 用户数据不会丢失

## 待决问题

- [ ] 播放列表的最大数量限制？（建议：无限制，但需要测试性能）
- [ ] 播放列表名称的字符限制？（建议：50 个字符）
- [ ] 删除播放列表时，如果该播放列表正在播放，如何处理？（建议：切换到默认播放列表并停止播放）

