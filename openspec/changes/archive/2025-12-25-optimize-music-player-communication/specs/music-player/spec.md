## 优化需求

### 需求：组件通信方式优化

系统必须优化音乐播放器的组件通信方式，使用 provide/inject API 和事件总线替代单一的 props 传递。

#### 场景：使用 Provide/Inject 共享状态

- **当** 父组件 `MusicPlayer.vue` 初始化时
- **那么** 系统必须通过 `provide` API 提供 `MusicPlayerContext`
- **并且** 必须使用 `Symbol` 作为注入键以提高类型提示能力
- **并且** 上下文必须包含所有播放状态（isPlaying、isLoading、currentTime、duration）
- **并且** 上下文必须包含当前曲目信息（currentTrack、currentTrackId）
- **并且** 上下文必须包含播放列表信息（playlist、filteredPlaylist、searchQuery、sortOption、sortOrder）
- **并且** 上下文必须包含播放模式（playMode）和音量（volume）
- **并且** 上下文必须包含工具函数（formatTime）

#### 场景：子组件注入上下文

- **当** 子组件 `PlayerPanel.vue` 或 `PlaylistPanel.vue` 初始化时
- **那么** 系统必须通过 `inject` API 获取 `MusicPlayerContext`
- **并且** 如果上下文不存在，系统必须抛出错误提示组件必须在 MusicPlayerProvider 内使用
- **并且** 子组件必须直接使用 Ref 和 ComputedRef 对象，而非 `.value` 快照值

#### 场景：使用事件总线处理跨组件通信

- **当** 子组件需要通知父组件执行操作时
- **那么** 系统必须使用 mitt 事件总线发送事件
- **并且** 事件类型必须包含：play、pause、next、previous、progressChange、volumeChange、playModeToggle、selectFolder、trackSelect、sortOptionChange
- **并且** 父组件必须监听事件总线并执行相应的操作

### 需求：响应式状态管理优化

系统必须确保所有状态变更能够自动触发响应式更新。

#### 场景：直接传递 Ref/ComputedRef 对象

- **当** 系统提供上下文时
- **那么** 必须直接传递 Ref 和 ComputedRef 对象
- **并且** 不得在 context 对象中使用 `.value` 获取快照值
- **并且** 确保状态变更时自动触发响应式更新

#### 场景：优化播放列表更新逻辑

- **当** 用户添加音乐到播放列表时
- **那么** 系统必须直接修改 `playerState.value.playlist`
- **并且** 不得使用 computed 属性来更新播放列表
- **并且** 异步存储加载不得覆盖用户新添加的音乐

#### 场景：Context 接口类型定义

- **当** 定义 PlayerContext 接口时
- **那么** 接口必须使用正确的响应式类型
- **并且** 布尔类型状态必须使用 `Ref<boolean>`
- **并且** 数值类型状态必须使用 `Ref<number>`
- **并且** 计算属性必须使用 `ComputedRef<T>` 类型
- **并且** 数组类型必须使用 `Ref<Array<T>>` 或 `ComputedRef<Array<T>>` 类型

### 需求：事件处理优化

系统必须优化事件处理方式，确保资源正确释放。

#### 场景：使用 useEmitter 管理事件监听

- **当** 组件需要监听事件总线时
- **那么** 系统必须使用 `useEmitter` hook
- **并且** 组件卸载时必须自动移除所有事件监听器
- **并且** 不得直接使用 `eventBus.on` 或 `eventBus.off`

#### 场景：事件处理函数定义

- **当** 定义事件处理函数时
- **那么** 事件类型必须与 mitt 类型定义保持一致
- **并且** 事件参数类型必须明确声明
- **并且** 必须处理可选参数的情况

### 需求：纯函数抽离

系统必须将可复用的逻辑抽离为独立的工具函数。

#### 场景：时间格式化函数

- **当** 需要格式化播放时间时
- **那么** 系统必须使用 `formatTime` 函数
- **并且** 函数必须将秒数转换为 `mm:ss` 格式
- **并且** 无效输入（NaN 或负数）必须返回 `00:00`

#### 场景：曲目信息获取函数

- **当** 需要获取曲目标题或艺术家时
- **那么** 系统必须使用 `getTrackTitle` 函数获取标题
- **并且** 系统必须使用 `getTrackArtist` 函数获取艺术家
- **并且** 如果元数据不存在，必须返回默认值（未知曲目、未知艺术家）

#### 场景：播放模式辅助函数

- **当** 需要获取播放模式图标或标签时
- **那么** 系统必须使用 `getPlayModeIcon` 函数获取图标
- **并且** 系统必须使用 `getPlayModeLabel` 函数获取标签
- **并且** 必须支持顺序播放、循环播放、随机播放三种模式

### 需求：代码结构优化

系统必须优化代码结构，减少组件耦合度。

#### 场景：移除 Props 传递链

- **当** 优化组件通信后
- **那么** 父组件不得通过 props 传递大量状态给子组件
- **并且** 子组件不得定义大量 props 接口
- **并且** 添加新功能时不得修改父组件和子组件的 props 定义

#### 场景：创建上下文钩子

- **当** 外部组件需要获取上下文时
- **那么** 系统必须提供 `useMusicPlayerContext` hook
- **并且** hook 必须返回带有默认值的上下文对象
- **并且** 不得直接使用 `MusicPlayerContextKey` 进行注入

#### 场景：文件目录结构

- **当** 实现优化方案时
- **那么** 上下文定义必须放在 `src/views/MusicPlayer/contexts/PlayerContext.ts`
- **并且** 工具函数必须放在 `src/views/MusicPlayer/utils/` 目录
- **并且** 类型定义必须放在 `src/views/MusicPlayer/types/` 目录

### 需求：类型安全增强

系统必须通过类型定义确保代码的类型安全。

#### 场景：事件类型定义

- **当** 定义事件总线类型时
- **那么** 必须使用 TypeScript 泛型约束事件类型
- **并且** play 事件必须有 track id 参数
- **并且** pause、next、previous 事件必须无参数或参数为 void

#### 场景：上下文类型定义

- **当** 定义 MusicPlayerContext 接口时
- **那么** 所有属性必须有明确的类型
- **并且** 工具函数必须有参数和返回值类型
- **并且** 枚举类型必须有明确的字面量类型

### 需求：向后兼容性

系统必须确保优化后的代码与现有功能兼容。

#### 场景：保持现有功能不变

- **当** 重构组件通信方式时
- **那么** 播放、暂停、上一首、下一首等功能必须正常工作
- **并且** 进度条和音量控制必须正常工作
- **并且** 播放模式切换必须正常工作
- **并且** 播放列表管理必须正常工作
- **并且** 文件导入和拖拽功能必须正常工作

#### 场景：性能无损耗

- **当** 优化组件通信后
- **那么** 组件渲染性能不得下降
- **并且** 事件处理响应时间不得增加
- **并且** 必须没有内存泄漏

### 验收标准

1. **代码结构**：
   - 父组件 `MusicPlayer.vue` 代码量减少
   - 子组件 `PlayerPanel.vue` 和 `PlaylistPanel.vue` 不再依赖大量 props
   - 上下文和工具函数独立到专门的文件

2. **类型安全**：
   - 使用 Symbol 作为 provide 的 key
   - PlayerContext 接口完整定义所有响应式类型
   - 事件类型有完整的 TypeScript 类型定义

3. **功能验证**：
   - 所有播放控制功能正常工作
   - 播放列表更新正确响应
   - 事件总线通信正常

4. **代码质量**：
   - 通过 lint 检查
   - 通过类型检查
   - 代码格式符合项目规范
