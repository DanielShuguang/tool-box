## 上下文

当前画板功能仅支持基本图形绘制（线条、矩形、圆形等），使用 Canvas API 进行渲染。画板元素数据存储在 Pinia store 中，每个元素都有统一的数据结构。用户需要插入图片功能来增强画板的实用性，支持从本地文件、剪贴板和拖拽三种方式插入图片，并支持移动、缩放、旋转等操作。

## 目标 / 非目标

**目标：**

- 实现图片插入功能，支持 PNG、JPEG、WebP 等常见图片格式
- 支持三种图片来源：本地文件选择、剪贴板粘贴、拖拽上传
- 支持图片在画板中的移动、缩放、旋转操作
- 图片元素与现有图形元素统一管理，保持数据结构一致性
- 图片渲染性能良好，不影响画板整体流畅度

**非目标：**

- 不支持图片编辑功能（如裁剪、滤镜等）
- 不支持图片导出功能（画板整体导出时包含图片即可）
- 不支持图片图层管理（图片与其他元素在同一层级）
- 不支持图片格式转换

## 决策

### 图片数据存储方式

**决策**：使用 Base64 编码存储图片数据在画板元素中

**理由**：

- 简化数据序列化和反序列化，便于画板状态的保存和恢复
- 避免文件路径依赖，确保画板数据可移植
- 与现有元素数据结构保持一致

**替代方案**：

- 使用文件路径：需要处理文件路径变化、文件删除等问题，复杂度高
- 使用 Blob URL：Blob URL 仅在当前会话有效，不适合持久化存储

### 图片渲染方式

**决策**：使用 Canvas API 的 `drawImage` 方法渲染图片

**理由**：

- 与现有画板渲染方式一致，无需引入新的渲染引擎
- 性能良好，支持硬件加速
- 可以方便地应用变换（移动、缩放、旋转）

**替代方案**：

- 使用 SVG：需要将图片转换为 SVG，增加复杂度
- 使用 HTML img 元素：与 Canvas 渲染方式不一致，难以统一管理

### 图片变换实现

**决策**：使用 Canvas 的 `save()`、`translate()`、`rotate()`、`scale()`、`restore()` 方法实现图片变换

**理由**：

- Canvas 原生支持，无需额外依赖
- 性能良好，变换操作高效
- 与现有图形变换方式一致

**替代方案**：

- 使用 CSS transform：仅适用于 DOM 元素，不适用于 Canvas
- 手动计算变换矩阵：复杂度高，容易出错

### 图片来源处理

**决策**：

- 本地文件：使用 `<input type="file">` 选择文件，使用 FileReader 读取为 Base64
- 剪贴板：使用 Clipboard API 读取剪贴板中的图片
- 拖拽：监听 `drop` 事件，从 `DataTransfer` 对象获取图片文件

**理由**：

- 使用浏览器原生 API，无需额外依赖
- 三种方式统一转换为 Base64 存储，便于管理

**替代方案**：

- 使用 Tauri 命令处理文件：增加前后端通信复杂度，对于纯前端功能不必要

### 图片格式支持

**决策**：支持浏览器原生支持的图片格式（PNG、JPEG、WebP、GIF、BMP）

**理由**：

- 浏览器原生支持，无需额外解码库
- 覆盖常见使用场景

**替代方案**：

- 引入图片解码库（如 sharp.js）：增加依赖和打包体积，对于简单解码场景不必要

## 风险 / 权衡

### 内存占用风险

**风险**：Base64 编码会增加约 33% 的数据大小，大量图片可能导致内存占用过高

**缓解措施**：

- 限制图片最大尺寸（如 4096x4096）
- 在插入前对大图片进行压缩
- 提示用户图片过大时的风险

### 性能风险

**风险**：大量图片可能导致渲染性能下降

**缓解措施**：

- 使用离屏 Canvas 缓存已渲染的图片
- 实现视口裁剪，只渲染可见区域的图片
- 提供图片质量设置选项

### 兼容性风险

**风险**：不同浏览器对图片格式和 API 的支持程度不同

**缓解措施**：

- 使用标准 Web API，避免使用实验性功能
- 提供降级方案，不支持时给出友好提示

## 迁移计划

无需迁移计划，这是新增功能，不影响现有功能。

## 开放问题

1. 图片最大尺寸限制：是否需要限制图片最大尺寸？限制为多少？
2. 图片压缩质量：是否需要对插入的图片进行压缩？压缩质量如何设置？
3. 图片默认大小：插入图片时的默认大小如何设置？
